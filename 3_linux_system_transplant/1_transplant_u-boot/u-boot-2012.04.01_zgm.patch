diff -urN u-boot-2012.04.01/arch/arm/config.mk u-boot-2012.04.01_zgm/arch/arm/config.mk
--- u-boot-2012.04.01/arch/arm/config.mk	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/arch/arm/config.mk	2022-07-02 03:53:42.496599223 +0800
@@ -72,5 +72,5 @@
 
 # needed for relocation
 ifndef CONFIG_NAND_SPL
-LDFLAGS_u-boot += -pie
+//LDFLAGS_u-boot += -pie
 endif
diff -urN u-boot-2012.04.01/arch/arm/cpu/arm920t/start.S u-boot-2012.04.01_zgm/arch/arm/cpu/arm920t/start.S
--- u-boot-2012.04.01/arch/arm/cpu/arm920t/start.S	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/arch/arm/cpu/arm920t/start.S	2022-07-02 03:56:23.859996650 +0800
@@ -27,6 +27,7 @@
 #include <asm-offsets.h>
 #include <common.h>
 #include <config.h>
+#define S3C2440_MPLL_400MHZ     ((0x5c<<12)|(0x01<<4)|(0x01))
 
 /*
  *************************************************************************
@@ -109,7 +110,9 @@
 .globl IRQ_STACK_START_IN
 IRQ_STACK_START_IN:
 	.word	0x0badc0de
-
+.globl base_sp
+base_sp:
+	.long 0
 /*
  * the actual start code
  */
@@ -169,9 +172,31 @@
 
 	/* FCLK:HCLK:PCLK = 1:2:4 */
 	/* default FCLK is 120 MHz ! */
-	ldr	r0, =CLKDIVN
-	mov	r1, #3
-	str	r1, [r0]
+//	ldr	r0, =CLKDIVN
+//	mov	r1, #3
+//	str	r1, [r0]
+
+/* 2. 设置时钟 */
+	ldr r0, =0x4c000014
+	//	mov r1, #0x03;			  // FCLK:HCLK:PCLK=1:2:4, HDIVN=1,PDIVN=1
+	mov r1, #0x05;			  // FCLK:HCLK:PCLK=1:4:8
+	str r1, [r0]
+
+	/* 如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode” */
+	mrc	p15, 0, r1, c1, c0, 0		/* 读出控制寄存器 */ 
+	orr	r1, r1, #0xc0000000			/* 设置为“asynchronous bus mode” */
+	mcr	p15, 0, r1, c1, c0, 0		/* 写入控制寄存器 */
+
+	/* MPLLCON = S3C2440_MPLL_200MHZ */
+	ldr r0, =0x4c000004
+	ldr r1, =S3C2440_MPLL_400MHZ
+	str r1, [r0]
+
+	/* 启动ICACHE */
+	mrc p15, 0, r0, c1, c0, 0	@ read control reg
+	orr r0, r0, #(1<<12)
+	mcr	p15, 0, r0, c1, c0, 0   @ write it back
+
 #endif	/* CONFIG_S3C24X0 */
 
 	/*
@@ -181,104 +206,34 @@
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 	bl	cpu_init_crit
 #endif
-
-/* Set stackpointer in internal RAM to call board_init_f */
-call_board_init_f:
 	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
 	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
-	ldr	r0,=0x00000000
-	bl	board_init_f
-
-/*------------------------------------------------------------------------------*/
-
-/*
- * void relocate_code (addr_sp, gd, addr_moni)
- *
- * This "function" does not return, instead it continues in RAM
- * after relocating the monitor code.
- *
- */
-	.globl	relocate_code
-relocate_code:
-	mov	r4, r0	/* save addr_sp */
-	mov	r5, r1	/* save addr of gd */
-	mov	r6, r2	/* save addr of destination */
-
-	/* Set up the stack						    */
-stack_setup:
-	mov	sp, r4
-
-	adr	r0, _start
-	cmp	r0, r6
-	beq	clear_bss		/* skip relocation */
-	mov	r1, r6			/* r1 <- scratch for copy_loop */
-	ldr	r3, _bss_start_ofs
-	add	r2, r0, r3		/* r2 <- source end address	    */
-
-copy_loop:
-	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	blo	copy_loop
 
-#ifndef CONFIG_SPL_BUILD
-	/*
-	 * fix .rel.dyn relocations
-	 */
-	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
-	sub	r9, r6, r0		/* r9 <- relocation offset */
-	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
-	add	r10, r10, r0		/* r10 <- sym table in FLASH */
-	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
-	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
-	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
-	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
-fixloop:
-	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
-	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
-	ldr	r1, [r2, #4]
-	and	r7, r1, #0xff
-	cmp	r7, #23			/* relative fixup? */
-	beq	fixrel
-	cmp	r7, #2			/* absolute fixup? */
-	beq	fixabs
-	/* ignore unknown type of fixup */
-	b	fixnext
-fixabs:
-	/* absolute fix: set location to (offset) symbol value */
-	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
-	add	r1, r10, r1		/* r1 <- address of symbol in table */
-	ldr	r1, [r1, #4]		/* r1 <- symbol value */
-	add	r1, r1, r9		/* r1 <- relocated sym addr */
-	b	fixnext
-fixrel:
-	/* relative fix: increase location by offset */
-	ldr	r1, [r0]
-	add	r1, r1, r9
-fixnext:
-	str	r1, [r0]
-	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
-	cmp	r2, r3
-	blo	fixloop
-#endif
-
-clear_bss:
-#ifndef CONFIG_SPL_BUILD
-	ldr	r0, _bss_start_ofs
-	ldr	r1, _bss_end_ofs
-	mov	r4, r6			/* reloc addr */
-	add	r0, r0, r4
-	add	r1, r1, r4
-	mov	r2, #0x00000000		/* clear			    */
-
-clbss_l:str	r2, [r0]		/* clear loop...		    */
-	add	r0, r0, #4
-	cmp	r0, r1
-	bne	clbss_l
+	bl nand_init_ll
+	mov r0, #0
+//	ldr r1, =_start
+	ldr r1, _TEXT_BASE
+	ldr r2, _bss_start_ofs
+
+	bl copy_code_to_sdram
+	bl clear_bss
+	
+	ldr pc, =call_board_init_f
+	
+/* Set stackpointer in internal RAM to call board_init_f */
+call_board_init_f:
 
-	bl coloured_LED_init
-	bl red_led_on
-#endif
+	ldr	r0,=0x00000000
+	bl board_init_f
+	
+	/*board_init_r的第1个实参id:
+		unsigned int的值经board_init_f返回后存在r0里，正好给board_init_r使用；
+	  board_init_r的第2个实参dest_addr:	
+		就是程序的链接地址 _TEXT_BASE
+	*/
+	ldr	r1, _TEXT_BASE
+	ldr sp, base_sp
+	bl board_init_r
 
 /*
  * We are done. Do not return, instead branch to second part of board
diff -urN u-boot-2012.04.01/arch/arm/cpu/u-boot.lds u-boot-2012.04.01_zgm/arch/arm/cpu/u-boot.lds
--- u-boot-2012.04.01/arch/arm/cpu/u-boot.lds	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/arch/arm/cpu/u-boot.lds	2022-07-02 03:54:00.919995485 +0800
@@ -1,94 +1,53 @@
-/*
- * Copyright (c) 2004-2008 Texas Instruments
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
 OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
 OUTPUT_ARCH(arm)
 ENTRY(_start)
 SECTIONS
 {
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text :
-	{
-		__image_copy_start = .;
-		CPUDIR/start.o (.text)
-		*(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
-
-	. = ALIGN(4);
-	.data : {
-		*(.data)
-	}
-
-	. = ALIGN(4);
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-
-	__image_copy_end = .;
-
-	.rel.dyn : {
-		__rel_dyn_start = .;
-		*(.rel*)
-		__rel_dyn_end = .;
-	}
-
-	.dynsym : {
-		__dynsym_start = .;
-		*(.dynsym)
-	}
-
-	_end = .;
-
-	/*
-	 * Deprecated: this MMU section is used by pxa at present but
-	 * should not be used by new boards/CPUs.
-	 */
-	. = ALIGN(4096);
-	.mmutable : {
-		*(.mmutable)
-	}
-
-	.bss __rel_dyn_start (OVERLAY) : {
-		__bss_start = .;
-		*(.bss)
-		 . = ALIGN(4);
-		__bss_end__ = .;
-	}
-
-	/DISCARD/ : { *(.dynstr*) }
-	/DISCARD/ : { *(.dynamic*) }
-	/DISCARD/ : { *(.plt*) }
-	/DISCARD/ : { *(.interp*) }
-	/DISCARD/ : { *(.gnu*) }
+ . = 0x00000000;
+ . = ALIGN(4);
+ .text :
+ {
+  __image_copy_start = .;
+  arch/arm/cpu/arm920t/start.o (.text)
+  board/samsung/smdk2440/libsmdk2440.o(.text)
+  *(.text)
+ }
+ . = ALIGN(4);
+ .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+ . = ALIGN(4);
+ .data : {
+  *(.data)
+ }
+ . = ALIGN(4);
+ . = .;
+ __u_boot_cmd_start = .;
+ .u_boot_cmd : { *(.u_boot_cmd) }
+ __u_boot_cmd_end = .;
+ . = ALIGN(4);
+ __image_copy_end = .;
+ .rel.dyn : {
+  __rel_dyn_start = .;
+  *(.rel*)
+  __rel_dyn_end = .;
+ }
+ .dynsym : {
+  __dynsym_start = .;
+  *(.dynsym)
+ }
+ _end = .;
+ . = ALIGN(4096);
+ .mmutable : {
+  *(.mmutable)
+ }
+ .bss __rel_dyn_start (OVERLAY) : {
+  __bss_start = .;
+  *(.bss)
+   . = ALIGN(4);
+  __bss_end__ = .;
+ }
+ /DISCARD/ : { *(.dynstr*) }
+ /DISCARD/ : { *(.dynamic*) }
+ /DISCARD/ : { *(.plt*) }
+ /DISCARD/ : { *(.interp*) }
+ /DISCARD/ : { *(.gnu*) }
 }
diff -urN u-boot-2012.04.01/arch/arm/lib/board.c u-boot-2012.04.01_zgm/arch/arm/lib/board.c
--- u-boot-2012.04.01/arch/arm/lib/board.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/arch/arm/lib/board.c	2022-07-02 06:44:47.996962466 +0800
@@ -256,12 +256,13 @@
 	NULL,
 };
 
-void board_init_f(ulong bootflag)
+unsigned int board_init_f(ulong bootflag)
 {
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
 	gd_t *id;
 	ulong addr, addr_sp;
+	extern ulong base_sp;
 #ifdef CONFIG_PRAM
 	ulong reg;
 #endif
@@ -369,8 +370,9 @@
 	 * reserve memory for U-Boot code, data & bss
 	 * round down to next 4 kB limit
 	 */
-	addr -= gd->mon_len;
-	addr &= ~(4096 - 1);
+	//addr -= gd->mon_len;
+	//addr &= ~(4096 - 1);
+	addr = CONFIG_SYS_TEXT_BASE;
 
 	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
 
@@ -434,9 +436,11 @@
 	gd->reloc_off = addr - _TEXT_BASE;
 	debug("relocation Offset is: %08lx\n", gd->reloc_off);
 	memcpy(id, (void *)gd, sizeof(gd_t));
+	base_sp = addr_sp;
 
-	relocate_code(addr_sp, id, addr);
-
+	//relocate_code(addr_sp, id, addr);
+	return (unsigned int)id;
+	
 	/* NOTREACHED - relocate_code() does not return */
 }
 
@@ -524,8 +528,9 @@
 		print_size(flash_size, "\n");
 # endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
-		puts(failed);
-		hang();
+		puts("0 KB nor\n\r");
+	//	puts(failed);
+	//	hang();
 	}
 #endif
 
@@ -646,6 +651,8 @@
 		setenv("mem", (char *)memsz);
 	}
 #endif
+	run_command("mtdparts default", 0);
+	//mtdparts_init();
 
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
diff -urN u-boot-2012.04.01/board/samsung/smdk2440/init.c u-boot-2012.04.01_zgm/board/samsung/smdk2440/init.c
--- u-boot-2012.04.01/board/samsung/smdk2440/init.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/board/samsung/smdk2440/init.c	2022-07-02 03:59:11.124009681 +0800
@@ -0,0 +1,174 @@
+
+/* NAND FLASH控制器 */
+#define NFCONF (*((volatile unsigned long *)0x4E000000))
+#define NFCONT (*((volatile unsigned long *)0x4E000004))
+#define NFCMMD (*((volatile unsigned char *)0x4E000008))
+#define NFADDR (*((volatile unsigned char *)0x4E00000C))
+#define NFDATA (*((volatile unsigned char *)0x4E000010))
+#define NFSTAT (*((volatile unsigned char *)0x4E000020))
+
+/* GPIO */
+#define GPHCON              (*(volatile unsigned long *)0x56000070)
+#define GPHUP               (*(volatile unsigned long *)0x56000078)
+
+/* UART registers*/
+#define ULCON0              (*(volatile unsigned long *)0x50000000)
+#define UCON0               (*(volatile unsigned long *)0x50000004)
+#define UFCON0              (*(volatile unsigned long *)0x50000008)
+#define UMCON0              (*(volatile unsigned long *)0x5000000c)
+#define UTRSTAT0            (*(volatile unsigned long *)0x50000010)
+#define UTXH0               (*(volatile unsigned char *)0x50000020)
+#define URXH0               (*(volatile unsigned char *)0x50000024)
+#define UBRDIV0             (*(volatile unsigned long *)0x50000028)
+
+#define TXD0READY   (1<<2)
+
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len);
+
+
+static int isBootFromNorFlash(void)
+{
+	volatile int *p = (volatile int *)0;
+	int val;
+
+	val = *p;
+	*p = 0x12345678;
+	if (*p == 0x12345678)
+	{
+		/* 写成功, 是nand启动 */
+		*p = val;
+		return 0;
+	}
+	else
+	{
+		/* NOR不能像内存一样写 */
+		return 1;
+	}
+}
+
+void copy_code_to_sdram(unsigned char *src, unsigned char *dest, unsigned int len)
+{	
+	int i = 0;
+	
+	/* 如果是NOR启动 */
+	if (isBootFromNorFlash())
+	{
+		while (i < len)
+		{
+			dest[i] = src[i];
+			i++;
+		}
+	}
+	else
+	{
+		//nand_init();
+		nand_read_ll((unsigned int)src, dest, len);
+	}
+}
+
+void clear_bss(void)
+{
+	extern int __bss_start, __bss_end__;
+	int *p = &__bss_start;
+	
+	for (; p < &__bss_end__; p++)
+		*p = 0;
+}
+
+void nand_init_ll(void)
+{
+#define TACLS   0
+#define TWRPH0  1
+#define TWRPH1  0
+	/* 设置时序 */
+	NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+	/* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+	NFCONT = (1<<4)|(1<<1)|(1<<0);	
+}
+
+static void nand_select(void)
+{
+	NFCONT &= ~(1<<1);	
+}
+
+static void nand_deselect(void)
+{
+	NFCONT |= (1<<1);	
+}
+
+static void nand_cmd(unsigned char cmd)
+{
+	volatile int i;
+	NFCMMD = cmd;
+	for (i = 0; i < 10; i++);
+}
+
+static void nand_addr(unsigned int addr)
+{
+	unsigned int col  = addr % 2048;
+	unsigned int page = addr / 2048;
+	volatile int i;
+
+	NFADDR = col & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR = (col >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	
+	NFADDR  = page & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR  = (page >> 8) & 0xff;
+	for (i = 0; i < 10; i++);
+	NFADDR  = (page >> 16) & 0xff;
+	for (i = 0; i < 10; i++);	
+}
+
+static void nand_wait_ready(void)
+{
+	while (!(NFSTAT & 1));
+}
+
+static unsigned char nand_data(void)
+{
+	return NFDATA;
+}
+
+void nand_read_ll(unsigned int addr, unsigned char *buf, unsigned int len)
+{
+	int col = addr % 2048;
+	int i = 0;
+		
+	/* 1. 选中 */
+	nand_select();
+
+	while (i < len)
+	{
+		/* 2. 发出读命令00h */
+		nand_cmd(0x00);
+
+		/* 3. 发出地址(分5步发出) */
+		nand_addr(addr);
+
+		/* 4. 发出读命令30h */
+		nand_cmd(0x30);
+
+		/* 5. 判断状态 */
+		nand_wait_ready();
+
+		/* 6. 读数据 */
+		for (; (col < 2048) && (i < len); col++)
+		{
+			buf[i] = nand_data();
+			i++;
+			addr++;
+		}
+		
+		col = 0;
+	}
+
+	/* 7. 取消选中 */		
+	nand_deselect();
+}
+
+
+
diff -urN u-boot-2012.04.01/board/samsung/smdk2440/lowlevel_init.S u-boot-2012.04.01_zgm/board/samsung/smdk2440/lowlevel_init.S
--- u-boot-2012.04.01/board/samsung/smdk2440/lowlevel_init.S	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/board/samsung/smdk2440/lowlevel_init.S	2022-07-02 03:59:11.147977202 +0800
@@ -0,0 +1,168 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8			(0x0)
+#define DW16			(0x1)
+#define DW32			(0x2)
+#define WAIT			(0x1<<2)
+#define UBLB			(0x1<<3)
+
+#define B1_BWSCON		(DW32)
+#define B2_BWSCON		(DW16)
+#define B3_BWSCON		(DW16 + WAIT + UBLB)
+#define B4_BWSCON		(DW16)
+#define B5_BWSCON		(DW16)
+#define B6_BWSCON		(DW32)
+#define B7_BWSCON		(DW32)
+
+/* BANK0CON */
+#define B0_Tacs			0x0	/*  0clk */
+#define B0_Tcos			0x0	/*  0clk */
+#define B0_Tacc			0x7	/* 14clk */
+#define B0_Tcoh			0x0	/*  0clk */
+#define B0_Tah			0x0	/*  0clk */
+#define B0_Tacp			0x0
+#define B0_PMC			0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs			0x0	/*  0clk */
+#define B1_Tcos			0x0	/*  0clk */
+#define B1_Tacc			0x7	/* 14clk */
+#define B1_Tcoh			0x0	/*  0clk */
+#define B1_Tah			0x0	/*  0clk */
+#define B1_Tacp			0x0
+#define B1_PMC			0x0
+
+#define B2_Tacs			0x0
+#define B2_Tcos			0x0
+#define B2_Tacc			0x7
+#define B2_Tcoh			0x0
+#define B2_Tah			0x0
+#define B2_Tacp			0x0
+#define B2_PMC			0x0
+
+#define B3_Tacs			0x0	/*  0clk */
+#define B3_Tcos			0x3	/*  4clk */
+#define B3_Tacc			0x7	/* 14clk */
+#define B3_Tcoh			0x1	/*  1clk */
+#define B3_Tah			0x0	/*  0clk */
+#define B3_Tacp			0x3     /*  6clk */
+#define B3_PMC			0x0	/* normal */
+
+#define B4_Tacs			0x0	/*  0clk */
+#define B4_Tcos			0x0	/*  0clk */
+#define B4_Tacc			0x7	/* 14clk */
+#define B4_Tcoh			0x0	/*  0clk */
+#define B4_Tah			0x0	/*  0clk */
+#define B4_Tacp			0x0
+#define B4_PMC			0x0	/* normal */
+
+#define B5_Tacs			0x0	/*  0clk */
+#define B5_Tcos			0x0	/*  0clk */
+#define B5_Tacc			0x7	/* 14clk */
+#define B5_Tcoh			0x0	/*  0clk */
+#define B5_Tah			0x0	/*  0clk */
+#define B5_Tacp			0x0
+#define B5_PMC			0x0	/* normal */
+
+#define B6_MT			0x3	/* SDRAM */
+#define B6_Trcd			0x1
+#define B6_SCAN			0x1	/* 9bit */
+
+#define B7_MT			0x3	/* SDRAM */
+#define B7_Trcd			0x1	/* 3clk */
+#define B7_SCAN			0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN			0x1	/* Refresh enable */
+#define TREFMD			0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp			0x0	/* 2clk */
+#define Trc			0x3	/* 7clk */
+#define Tchr			0x2	/* 3clk */
+#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+_TEXT_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+		.long 0x22011110	 //BWSCON
+		.long 0x00000700	 //BANKCON0
+		.long 0x00000700	 //BANKCON1
+		.long 0x00000700	 //BANKCON2
+		.long 0x00000700	 //BANKCON3  
+		.long 0x00000740	 //BANKCON4
+		.long 0x00000700	 //BANKCON5
+		.long 0x00018005	 //BANKCON6
+		.long 0x00018005	 //BANKCON7
+		.long 0x008C04F4	 // REFRESH
+		.long 0x000000B1	 //BANKSIZE
+		.long 0x00000030	 //MRSRB6
+		.long 0x00000030	 //MRSRB7
+
diff -urN u-boot-2012.04.01/board/samsung/smdk2440/Makefile u-boot-2012.04.01_zgm/board/samsung/smdk2440/Makefile
--- u-boot-2012.04.01/board/samsung/smdk2440/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/board/samsung/smdk2440/Makefile	2022-07-02 03:59:11.152209566 +0800
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= smdk2440.o init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2012.04.01/board/samsung/smdk2440/smdk2440.c u-boot-2012.04.01_zgm/board/samsung/smdk2440/smdk2440.c
--- u-boot-2012.04.01/board/samsung/smdk2440/smdk2440.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/board/samsung/smdk2440/smdk2440.c	2022-07-02 10:34:14.956325506 +0800
@@ -0,0 +1,156 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002, 2010
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/s3c24x0_cpu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void pll_delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_early_init_f(void)
+{
+	struct s3c24x0_clock_power * const clk_power =
+					s3c24x0_get_base_clock_power();
+	struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	//writel(0xFFFFFF, &clk_power->locktime);
+
+	/* configure MPLL */
+	//writel((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV,
+	//       &clk_power->mpllcon);
+
+	/* some delay between MPLL and UPLL */
+	pll_delay(4000);
+
+	/* configure UPLL */
+	writel((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV,
+	       &clk_power->upllcon);
+
+	/* some delay between MPLL and UPLL */
+	pll_delay(8000);
+
+	/* set up the I/O ports */
+	writel(0x007FFFFF, &gpio->gpacon);
+	writel(0x00044555, &gpio->gpbcon);
+	writel(0x000007FF, &gpio->gpbup);
+	writel(0xAAAAAAAA, &gpio->gpccon);
+	writel(0x0000FFFF, &gpio->gpcup);
+	writel(0xAAAAAAAA, &gpio->gpdcon);
+	writel(0x0000FFFF, &gpio->gpdup);
+	writel(0xAAAAAAAA, &gpio->gpecon);
+	writel(0x0000FFFF, &gpio->gpeup);
+	writel(0x000055AA, &gpio->gpfcon);
+	writel(0x000000FF, &gpio->gpfup);
+	writel(0xFF95FFBA, &gpio->gpgcon);
+	writel(0x0000FFFF, &gpio->gpgup);
+	writel(0x002AFAAA, &gpio->gphcon);
+	writel(0x000007FF, &gpio->gphup);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* arch number of SMDK2440-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* dram_init must store complete ramsize in gd->ram_size */
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_CS8900
+	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
+#endif
+	rc = dm9000_initialize(bis);
+	return rc;
+}
+#endif
+
+/*
+ * Hardcoded flash setup:
+ * Flash 0 is a non-CFI AMD AM29LV800BB flash.
+ */
+ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info)
+{
+	info->portwidth = FLASH_CFI_16BIT;
+	info->chipwidth = FLASH_CFI_BY16;
+	info->interface = FLASH_CFI_X16;
+	return 1;
+}
diff -urN u-boot-2012.04.01/boards.cfg u-boot-2012.04.01_zgm/boards.cfg
--- u-boot-2012.04.01/boards.cfg	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/boards.cfg	2022-07-02 03:59:42.456897897 +0800
@@ -63,6 +63,7 @@
 cm41xx                       arm         arm920t     -                   -              ks8695
 VCMA9                        arm         arm920t     vcma9               mpl            s3c24x0
 smdk2410                     arm         arm920t     -                   samsung        s3c24x0
+smdk2440                     arm         arm920t     -                   samsung        s3c24x0
 omap1510inn                  arm         arm925t     -                   ti
 integratorap_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorap:CM926EJ_S
 integratorcp_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorcp:CM924EJ_S
diff -urN u-boot-2012.04.01/drivers/mtd/board.c u-boot-2012.04.01_zgm/drivers/mtd/board.c
--- u-boot-2012.04.01/drivers/mtd/board.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/drivers/mtd/board.c	2022-07-02 06:08:18.336455830 +0800
@@ -0,0 +1,669 @@
+/*
+ * (C) Copyright 2002-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * To match the U-Boot user interface on ARM platforms to the U-Boot
+ * standard (as on PPC platforms), some messages with debug character
+ * are removed from the default U-Boot build.
+ *
+ * Define DEBUG here if you want additional info as shown below
+ * printed upon startup:
+ *
+ * U-Boot code: 00F00000 -> 00F3C774  BSS: -> 00FC3274
+ * IRQ Stack: 00ebff7c
+ * FIQ Stack: 00ebef7c
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <version.h>
+#include <net.h>
+#include <serial.h>
+#include <nand.h>
+#include <onenand_uboot.h>
+#include <mmc.h>
+#include <libfdt.h>
+#include <fdtdec.h>
+#include <post.h>
+#include <logbuff.h>
+
+#ifdef CONFIG_BITBANGMII
+#include <miiphy.h>
+#endif
+
+#ifdef CONFIG_DRIVER_SMC91111
+#include "../drivers/net/smc91111.h"
+#endif
+#ifdef CONFIG_DRIVER_LAN91C96
+#include "../drivers/net/lan91c96.h"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ulong monitor_flash_len;
+
+#ifdef CONFIG_HAS_DATAFLASH
+extern int  AT91F_DataflashInit(void);
+extern void dataflash_print_info(void);
+#endif
+
+#if defined(CONFIG_HARD_I2C) || \
+    defined(CONFIG_SOFT_I2C)
+#include <i2c.h>
+#endif
+
+/************************************************************************
+ * Coloured LED functionality
+ ************************************************************************
+ * May be supplied by boards if desired
+ */
+inline void __coloured_LED_init(void) {}
+void coloured_LED_init(void)
+	__attribute__((weak, alias("__coloured_LED_init")));
+inline void __red_led_on(void) {}
+void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
+inline void __red_led_off(void) {}
+void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
+inline void __green_led_on(void) {}
+void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
+inline void __green_led_off(void) {}
+void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
+inline void __yellow_led_on(void) {}
+void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
+inline void __yellow_led_off(void) {}
+void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
+inline void __blue_led_on(void) {}
+void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
+inline void __blue_led_off(void) {}
+void blue_led_off(void) __attribute__((weak, alias("__blue_led_off")));
+
+/*
+ ************************************************************************
+ * Init Utilities							*
+ ************************************************************************
+ * Some of this code should be moved into the core functions,
+ * or dropped completely,
+ * but let's get it working (again) first...
+ */
+
+#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
+#define CONFIG_BAUDRATE 115200
+#endif
+
+static int init_baudrate(void)
+{
+	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
+	return 0;
+}
+
+static int display_banner(void)
+{
+	printf("\n\n%s\n\n", version_string);
+	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	       _TEXT_BASE,
+	       _bss_start_ofs + _TEXT_BASE, _bss_end_ofs + _TEXT_BASE);
+#ifdef CONFIG_MODEM_SUPPORT
+	debug("Modem Support enabled\n");
+#endif
+#ifdef CONFIG_USE_IRQ
+	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
+	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
+#endif
+
+	return (0);
+}
+
+/*
+ * WARNING: this code looks "cleaner" than the PowerPC version, but
+ * has the disadvantage that you either get nothing, or everything.
+ * On PowerPC, you might see "DRAM: " before the system hangs - which
+ * gives a simple yet clear indication which part of the
+ * initialization if failing.
+ */
+static int display_dram_config(void)
+{
+	int i;
+
+#ifdef DEBUG
+	puts("RAM Configuration:\n");
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		printf("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
+		print_size(gd->bd->bi_dram[i].size, "\n");
+	}
+#else
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		size += gd->bd->bi_dram[i].size;
+
+	puts("DRAM:  ");
+	print_size(size, "\n");
+#endif
+
+	return (0);
+}
+
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+static int init_func_i2c(void)
+{
+	puts("I2C:   ");
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	puts("ready\n");
+	return (0);
+}
+#endif
+
+#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
+#include <pci.h>
+static int arm_pci_init(void)
+{
+	pci_init();
+	return 0;
+}
+#endif /* CONFIG_CMD_PCI || CONFIG_PCI */
+
+/*
+ * Breathe some life into the board...
+ *
+ * Initialize a serial port as console, and carry out some hardware
+ * tests.
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependent #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+int print_cpuinfo(void);
+
+void __dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	gd->bd->bi_dram[0].size =  gd->ram_size;
+}
+void dram_init_banksize(void)
+	__attribute__((weak, alias("__dram_init_banksize")));
+
+init_fnc_t *init_sequence[] = {
+#if defined(CONFIG_ARCH_CPU_INIT)
+	arch_cpu_init,		/* basic arch cpu dependent setup */
+#endif
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+	board_early_init_f,
+#endif
+#ifdef CONFIG_OF_CONTROL
+	fdtdec_check_fdt,
+#endif
+	timer_init,		/* initialize timer */
+#ifdef CONFIG_FSL_ESDHC
+	get_clocks,
+#endif
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,		/* stage 1 init of console */
+	display_banner,		/* say that we are here */
+#if defined(CONFIG_DISPLAY_CPUINFO)
+	print_cpuinfo,		/* display cpu info (and speed) */
+#endif
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+	checkboard,		/* display board info */
+#endif
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+	init_func_i2c,
+#endif
+	dram_init,		/* configure available RAM banks */
+	NULL,
+};
+
+unsigned int board_init_f(ulong bootflag)
+{
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	gd_t *id;
+	ulong addr, addr_sp;
+	extern ulong base_sp;
+#ifdef CONFIG_PRAM
+	ulong reg;
+#endif
+
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");
+
+	/* Pointer is writable since we allocated a register for it */
+	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	gd->mon_len = _bss_end_ofs;
+#ifdef CONFIG_OF_EMBED
+	/* Get a pointer to the FDT */
+	gd->fdt_blob = _binary_dt_dtb_start;
+#elif defined CONFIG_OF_SEPARATE
+	/* FDT is at end of image */
+	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
+#endif
+	/* Allow the early environment to override the fdt address */
+	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
+						(uintptr_t)gd->fdt_blob);
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+#ifdef CONFIG_OF_CONTROL
+	/* For now, put this check after the console is ready */
+	if (fdtdec_prepare_fdt()) {
+		panic("** CONFIG_OF_CONTROL defined but no FDT - please see "
+			"doc/README.fdt-control");
+	}
+#endif
+
+	debug("monitor len: %08lX\n", gd->mon_len);
+	/*
+	 * Ram is setup, size stored in gd !!
+	 */
+	debug("ramsize: %08lX\n", gd->ram_size);
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	/*
+	 * Subtract specified amount of memory to hide so that it won't
+	 * get "touched" at all by U-Boot. By fixing up gd->ram_size
+	 * the Linux kernel should now get passed the now "corrected"
+	 * memory size and won't touch it either. This should work
+	 * for arch/ppc and arch/powerpc. Only Linux board ports in
+	 * arch/powerpc with bootwrapper support, that recalculate the
+	 * memory size from the SDRAM controller setup will have to
+	 * get fixed.
+	 */
+	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
+	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
+
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+	/* reserve kernel log buffer */
+	addr -= (LOGBUFF_RESERVE);
+	debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
+		addr);
+#endif
+#endif
+
+#ifdef CONFIG_PRAM
+	/*
+	 * reserve protected RAM
+	 */
+	reg = getenv_ulong("pram", 10, CONFIG_PRAM);
+	addr -= (reg << 10);		/* size is in kB */
+	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
+#endif /* CONFIG_PRAM */
+
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
+	/* reserve TLB table */
+	addr -= (4096 * 4);
+
+	/* round down to next 64 kB limit */
+	addr &= ~(0x10000 - 1);
+
+	gd->tlb_addr = addr;
+	debug("TLB table at: %08lx\n", addr);
+#endif
+
+	/* round down to next 4 kB limit */
+	addr &= ~(4096 - 1);
+	debug("Top of RAM usable for U-Boot at: %08lx\n", addr);
+
+#ifdef CONFIG_LCD
+#ifdef CONFIG_FB_ADDR
+	gd->fb_base = CONFIG_FB_ADDR;
+#else
+	/* reserve memory for LCD display (always full pages) */
+	addr = lcd_setmem(addr);
+	gd->fb_base = addr;
+#endif /* CONFIG_FB_ADDR */
+#endif /* CONFIG_LCD */
+
+	/*
+	 * reserve memory for U-Boot code, data & bss
+	 * round down to next 4 kB limit
+	 */
+	//addr -= gd->mon_len;
+	//addr &= ~(4096 - 1);
+	addr = CONFIG_SYS_TEXT_BASE;
+
+	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
+
+#ifndef CONFIG_SPL_BUILD
+	/*
+	 * reserve memory for malloc() arena
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+	debug("Reserving %dk for malloc() at: %08lx\n",
+			TOTAL_MALLOC_LEN >> 10, addr_sp);
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof (bd_t);
+	bd = (bd_t *) addr_sp;
+	gd->bd = bd;
+	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
+			sizeof (bd_t), addr_sp);
+
+#ifdef CONFIG_MACH_TYPE
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
+#endif
+
+	addr_sp -= sizeof (gd_t);
+	id = (gd_t *) addr_sp;
+	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
+			sizeof (gd_t), addr_sp);
+
+	/* setup stackpointer for exeptions */
+	gd->irq_sp = addr_sp;
+#ifdef CONFIG_USE_IRQ
+	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
+	debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
+		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);
+#endif
+	/* leave 3 words for abort-stack    */
+	addr_sp -= 12;
+
+	/* 8-byte alignment for ABI compliance */
+	addr_sp &= ~0x07;
+#else
+	addr_sp += 128;	/* leave 32 words for abort-stack   */
+	gd->irq_sp = addr_sp;
+#endif
+
+	debug("New Stack Pointer is: %08lx\n", addr_sp);
+
+#ifdef CONFIG_POST
+	post_bootmode_init();
+	post_run(NULL, POST_ROM | post_bootmode_get(0));
+#endif
+
+	gd->bd->bi_baudrate = gd->baudrate;
+	/* Ram ist board specific, so move it to board code ... */
+	dram_init_banksize();
+	display_dram_config();	/* and display it */
+
+	gd->relocaddr = addr;
+	gd->start_addr_sp = addr_sp;
+	gd->reloc_off = addr - _TEXT_BASE;
+	debug("relocation Offset is: %08lx\n", gd->reloc_off);
+	memcpy(id, (void *)gd, sizeof(gd_t));
+	base_sp = addr_sp;
+
+	//relocate_code(addr_sp, id, addr);
+	return (unsigned int)id;
+	
+	/* NOTREACHED - relocate_code() does not return */
+}
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+static char *failed = "*** failed ***\n";
+#endif
+
+/*
+ ************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void board_init_r(gd_t *id, ulong dest_addr)
+{
+	ulong malloc_start;
+#if !defined(CONFIG_SYS_NO_FLASH)
+	ulong flash_size;
+#endif
+
+	gd = id;
+
+	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");
+
+	monitor_flash_len = _end_ofs;
+
+	/* Enable caches */
+	enable_caches();
+
+	debug("monitor flash len: %08lX\n", monitor_flash_len);
+	board_init();	/* Setup chipselects */
+	/*
+	 * TODO: printing of the clock inforamtion of the board is now
+	 * implemented as part of bdinfo command. Currently only support for
+	 * davinci SOC's is added. Remove this check once all the board
+	 * implement this.
+	 */
+#ifdef CONFIG_CLOCKS
+	set_cpu_clk_info(); /* Setup clock information */
+#endif
+#ifdef CONFIG_SERIAL_MULTI
+	serial_initialize();
+#endif
+
+	debug("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
+
+#ifdef CONFIG_LOGBUFFER
+	logbuff_init_ptrs();
+#endif
+#ifdef CONFIG_POST
+	post_output_backlog();
+#endif
+
+	/* The Malloc area is immediately below the monitor copy in DRAM */
+	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+	puts("Flash: ");
+
+	flash_size = flash_init();
+	if (flash_size > 0) {
+# ifdef CONFIG_SYS_FLASH_CHECKSUM
+		char *s = getenv("flashchecksum");
+
+		print_size(flash_size, "");
+		/*
+		 * Compute and print flash CRC if flashchecksum is set to 'y'
+		 *
+		 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
+		 */
+		if (s && (*s == 'y')) {
+			printf("  CRC: %08X", crc32(0,
+				(const unsigned char *) CONFIG_SYS_FLASH_BASE,
+				flash_size));
+		}
+		putc('\n');
+# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
+		print_size(flash_size, "\n");
+# endif /* CONFIG_SYS_FLASH_CHECKSUM */
+	} else {
+		puts("0 KB nor\n\r");
+	//	puts(failed);
+	//	hang();
+	}
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+	puts("NAND:  ");
+	nand_init();		/* go init the NAND */
+#endif
+
+#if defined(CONFIG_CMD_ONENAND)
+	onenand_init();
+#endif
+
+#ifdef CONFIG_GENERIC_MMC
+       puts("MMC:   ");
+       mmc_initialize(gd->bd);
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+	AT91F_DataflashInit();
+	dataflash_print_info();
+#endif
+
+	/* initialize environment */
+	env_relocate();
+
+#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
+	arm_pci_init();
+#endif
+
+	/* IP Address */
+	gd->bd->bi_ip_addr = getenv_IPaddr("ipaddr");
+
+	stdio_init();	/* get the devices list going. */
+
+	jumptable_init();
+
+#if defined(CONFIG_API)
+	/* Initialize API */
+	api_init();
+#endif
+
+	console_init_r();	/* fully init console as a device */
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+	/* miscellaneous arch dependent initialisations */
+	arch_misc_init();
+#endif
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r();
+#endif
+
+	 /* set up exceptions */
+	interrupt_init();
+	/* enable exceptions */
+	enable_interrupts();
+
+	/* Perform network card initialisation if necessary */
+#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
+	/* XXX: this needs to be moved to board init */
+	if (getenv("ethaddr")) {
+		uchar enetaddr[6];
+		eth_getenv_enetaddr("ethaddr", enetaddr);
+		smc_set_mac_addr(enetaddr);
+	}
+#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */
+
+	/* Initialize from environment */
+	load_addr = getenv_ulong("loadaddr", 16, load_addr);
+#if defined(CONFIG_CMD_NET)
+	{
+		char *s = getenv("bootfile");
+
+		if (s != NULL)
+			copy_filename(BootFile, s, sizeof(BootFile));
+	}
+#endif
+
+#ifdef CONFIG_BOARD_LATE_INIT
+	board_late_init();
+#endif
+
+#ifdef CONFIG_BITBANGMII
+	bb_miiphy_init();
+#endif
+#if defined(CONFIG_CMD_NET)
+	puts("Net:   ");
+	eth_initialize(gd->bd);
+#if defined(CONFIG_RESET_PHY_R)
+	debug("Reset Ethernet PHY\n");
+	reset_phy();
+#endif
+#endif
+
+#ifdef CONFIG_POST
+	post_run(NULL, POST_RAM | post_bootmode_get(0));
+#endif
+
+#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
+	/*
+	 * Export available size of memory for Linux,
+	 * taking into account the protected RAM at top of memory
+	 */
+	{
+		ulong pram = 0;
+		uchar memsz[32];
+
+#ifdef CONFIG_PRAM
+		pram = getenv_ulong("pram", 10, CONFIG_PRAM);
+#endif
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+		/* Also take the logbuffer into account (pram is in kB) */
+		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
+#endif
+#endif
+		sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
+		setenv("mem", (char *)memsz);
+	}
+#endif
+
+	mtdparts_init();
+
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
+
+void hang(void)
+{
+	puts("### ERROR ### Please RESET the board ###\n");
+	for (;;);
+}
diff -urN u-boot-2012.04.01/drivers/mtd/jedec_flash.c u-boot-2012.04.01_zgm/drivers/mtd/jedec_flash.c
--- u-boot-2012.04.01/drivers/mtd/jedec_flash.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/drivers/mtd/jedec_flash.c	2022-07-02 04:04:24.008045127 +0800
@@ -367,6 +367,23 @@
 		}
 	},
 #endif
+	{
+		.mfr_id		= (u16)MX_MANUFACT,
+		.dev_id		= 0x2249,
+		.name		= "MXIC MT29LV160DB",
+		.uaddr		= {
+			[1] = MTD_UADDR_0x0555_0x02AA /* x16 */
+		},
+		.DevSize	= SIZE_2MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(16*1024, 1),
+			ERASEINFO(8*1024, 2),
+			ERASEINFO(32*1024, 1),
+			ERASEINFO(64*1024,31),
+		}
+	},
 };
 
 static inline void fill_info(flash_info_t *info, const struct amd_flash_info *jedec_entry, ulong base)
diff -urN u-boot-2012.04.01/drivers/mtd/nand/Makefile u-boot-2012.04.01_zgm/drivers/mtd/nand/Makefile
--- u-boot-2012.04.01/drivers/mtd/nand/Makefile	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/drivers/mtd/nand/Makefile	2022-07-02 04:09:50.103996515 +0800
@@ -59,6 +59,7 @@
 COBJS-$(CONFIG_NAND_NDFC) += ndfc.o
 COBJS-$(CONFIG_NAND_NOMADIK) += nomadik.o
 COBJS-$(CONFIG_NAND_S3C2410) += s3c2410_nand.o
+COBJS-$(CONFIG_NAND_S3C2440) += s3c2440_nand.o
 COBJS-$(CONFIG_NAND_S3C64XX) += s3c64xx.o
 COBJS-$(CONFIG_NAND_SPEAR) += spr_nand.o
 COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
diff -urN u-boot-2012.04.01/drivers/mtd/nand/nand_util.c u-boot-2012.04.01_zgm/drivers/mtd/nand/nand_util.c
--- u-boot-2012.04.01/drivers/mtd/nand/nand_util.c	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/drivers/mtd/nand/nand_util.c	2022-07-02 09:38:00.250934146 +0800
@@ -515,7 +515,8 @@
 		return -EINVAL;
 	}
 
-	if (!need_skip && !(flags & WITH_DROP_FFS)) {
+	//if (!need_skip && !(flags & WITH_DROP_FFS)) {
+	if (!need_skip && !(flags & WITH_DROP_FFS) && !(flags & WITH_YAFFS_OOB)) {
 		rval = nand_write (nand, offset, length, buffer);
 		if (rval == 0)
 			return 0;
@@ -553,7 +554,7 @@
 
 			ops.len = pagesize;
 			ops.ooblen = nand->oobsize;
-			ops.mode = MTD_OOB_AUTO;
+			ops.mode = MTD_OOB_RAW;
 			ops.ooboffs = 0;
 
 			pages = write_size / pagesize_oob;
@@ -564,7 +565,7 @@
 				ops.oobbuf = ops.datbuf + pagesize;
 
 				rval = nand->write_oob(nand, offset, &ops);
-				if (!rval)
+				if (rval)
 					break;
 
 				offset += pagesize;
diff -urN u-boot-2012.04.01/drivers/mtd/nand/s3c2440_nand.c u-boot-2012.04.01_zgm/drivers/mtd/nand/s3c2440_nand.c
--- u-boot-2012.04.01/drivers/mtd/nand/s3c2440_nand.c	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/drivers/mtd/nand/s3c2440_nand.c	2022-07-02 04:10:56.644582332 +0800
@@ -0,0 +1,193 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <nand.h>
+#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/io.h>
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+#define S3C2410_ADDR_NALE 4
+#define S3C2410_ADDR_NCLE 8
+
+#ifdef CONFIG_NAND_SPL
+
+/* in the early stage of NAND flash booting, printf() is not available */
+#define printf(fmt, args...)
+
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+#endif
+
+#if 0
+static void s3c2440_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+
+	debug("hwcontrol(): 0x%02x 0x%02x\n", cmd, ctrl);
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		ulong IO_ADDR_W = (ulong)nand;
+
+		if (!(ctrl & NAND_CLE))
+			IO_ADDR_W |= S3C2410_ADDR_NCLE;
+		if (!(ctrl & NAND_ALE))
+			IO_ADDR_W |= S3C2410_ADDR_NALE;
+
+		chip->IO_ADDR_W = (void *)IO_ADDR_W;
+
+		if (ctrl & NAND_NCE)
+			writel(readl(&nand->nfconf) & ~S3C2410_NFCONF_nFCE,
+			       &nand->nfconf);
+		else
+			writel(readl(&nand->nfconf) | S3C2410_NFCONF_nFCE,
+			       &nand->nfconf);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, chip->IO_ADDR_W);
+}
+
+#else
+static void s3c2440_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+
+	if(ctrl & NAND_CLE){
+		//发命令
+		writeb(dat, &nand->nfcmd);
+	}else if(ctrl & NAND_ALE){
+		//发地址
+		writeb(dat, &nand->nfaddr);
+	}
+}
+#endif
+
+static int s3c2440_dev_ready(struct mtd_info *mtd)
+{
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+	debug("dev_ready\n");
+	return readl(&nand->nfstat) & 0x01;
+}
+
+static void s3c2440_nand_select(struct mtd_info *mtd, int chipnr)
+{
+	struct s3c2440_nand *nand = s3c2440_get_base_nand();
+
+	switch (chipnr) {
+		case -1:/*deselect*/
+			nand->nfcont |= (1<<1);
+			break;
+		case 0:/*select*/
+			nand->nfcont &= ~(1<<1);
+			break;
+
+		default:
+			BUG();
+	}
+}
+
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
+	struct s3c2440_nand *nand_reg = s3c2440_get_base_nand();
+
+	debug("board_nand_init()\n");
+
+	writel(readl(&clk_power->clkcon) | (1 << 4), &clk_power->clkcon);
+
+	/* initialize hardware */
+#if defined(CONFIG_S3C24XX_CUSTOM_NAND_TIMING)
+	tacls  = CONFIG_S3C24XX_TACLS;
+	twrph0 = CONFIG_S3C24XX_TWRPH0;
+	twrph1 =  CONFIG_S3C24XX_TWRPH1;
+#else
+	tacls = 4;
+	twrph0 = 8;
+	twrph1 = 8;
+#endif
+#if 0
+
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+#endif
+	cfg = ((tacls-1)<<12)|((twrph0-1)<<8)|((twrph1-1)<<4);
+	writel(cfg, &nand_reg->nfconf);
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = (void *)&nand_reg->nfdata;
+	nand->IO_ADDR_W = (void *)&nand_reg->nfdata;
+
+	nand->select_chip = s3c2440_nand_select;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+#ifdef CONFIG_NAND_SPL
+	nand->read_buf = nand_read_buf;
+#endif
+
+	/* hwcontrol always must be implemented */
+	nand->cmd_ctrl = s3c2440_hwcontrol;
+
+	nand->dev_ready = s3c2440_dev_ready;
+
+#ifdef CONFIG_S3C2410_NAND_HWECC
+	nand->ecc.hwctl = s3c2410_nand_enable_hwecc;
+	nand->ecc.calculate = s3c2410_nand_calculate_ecc;
+	nand->ecc.correct = s3c2410_nand_correct_data;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
+#else
+	nand->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_S3C2410_NAND_BBT
+	nand->options = NAND_USE_FLASH_BBT;
+#else
+	nand->options = 0;
+#endif
+
+	debug("end of nand_init\n");
+
+	return 0;
+}
diff -urN u-boot-2012.04.01/include/common.h u-boot-2012.04.01_zgm/include/common.h
--- u-boot-2012.04.01/include/common.h	2012-04-25 21:22:50.000000000 +0800
+++ u-boot-2012.04.01_zgm/include/common.h	2022-07-02 03:51:51.485165768 +0800
@@ -273,8 +273,8 @@
 extern char console_buffer[];
 
 /* arch/$(ARCH)/lib/board.c */
-void	board_init_f  (ulong) __attribute__ ((noreturn));
-void	board_init_r  (gd_t *, ulong) __attribute__ ((noreturn));
+unsigned int board_init_f  (ulong);
+void	board_init_r  (gd_t *, ulong);
 int	checkboard    (void);
 int	checkflash    (void);
 int	checkdram     (void);
diff -urN u-boot-2012.04.01/include/configs/smdk2440.h u-boot-2012.04.01_zgm/include/configs/smdk2440.h
--- u-boot-2012.04.01/include/configs/smdk2440.h	1970-01-01 07:00:00.000000000 +0700
+++ u-boot-2012.04.01_zgm/include/configs/smdk2440.h	2022-07-02 07:21:21.616209295 +0800
@@ -0,0 +1,281 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		/* This is an ARM920T Core */
+#define CONFIG_S3C24X0		/* in a SAMSUNG S3C24x0-type SoC */
+//#define CONFIG_S3C2410		/* specifically a SAMSUNG S3C2410 SoC */
+#define CONFIG_S3C2440		/* specifically a SAMSUNG S3C2440 SoC */
+
+#define CONFIG_SMDK2410		/* on a SAMSUNG SMDK2410 Board */
+
+#define CONFIG_SYS_TEXT_BASE	0x33f00000//fixed in code 
+
+#define CONFIG_SYS_ARM_CACHE_WRITETHROUGH
+
+/* input clock of PLL (the SMDK2410 has 12MHz input clock) */
+#define CONFIG_SYS_CLK_FREQ	12000000
+
+#undef CONFIG_USE_IRQ		/* we don't need IRQ/FIQ stuff */
+
+#define CONFIG_CMDLINE_TAG	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/*
+ * Hardware drivers
+ */
+#if 0
+#define CONFIG_CS8900		/* we have a CS8900 on-board */
+#define CONFIG_CS8900_BASE	0x19000300
+#define CONFIG_CS8900_BUS16	/* the Linux driver does accesses as shorts */
+#else
+#define CONFIG_DRIVER_DM9000	
+
+#define CONFIG_DM9000_BASE	0x20000000
+#define DM9000_IO	CONFIG_DM9000_BASE
+#define DM9000_DATA (CONFIG_DM9000_BASE + 4)
+
+#endif
+
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_S3C24X0_SERIAL
+#define CONFIG_SERIAL1		1	/* we use SERIAL 1 on SMDK2410 */
+
+/************************************************************
+ * USB support (currently only works with D-cache off)
+ ************************************************************/
+//#define CONFIG_USB_OHCI
+//#define CONFIG_USB_KEYBOARD
+//#define CONFIG_USB_STORAGE
+//#define CONFIG_DOS_PARTITION
+
+/************************************************************
+ * RTC
+ ************************************************************/
+//#define CONFIG_RTC_S3C24X0
+
+
+#define CONFIG_BAUDRATE		115200
+
+/*
+ * BOOTP options
+ */
+//#define CONFIG_BOOTP_BOOTFILESIZE
+//#define CONFIG_BOOTP_BOOTPATH
+//#define CONFIG_BOOTP_GATEWAY
+//#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_BSP
+#define CONFIG_CMD_CACHE
+//#define CONFIG_CMD_DATE
+//#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_NAND 
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+//#define CONFIG_CMD_USB
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_CMDLINE_EDITING
+
+/* autoboot */
+#define CONFIG_BOOTDELAY	5
+#define CONFIG_BOOT_RETRY_TIME	-1
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_NETMASK		255.255.255.0
+//pc
+//#define CONFIG_IPADDR		192.168.1.103
+//#define CONFIG_SERVERIP		192.168.1.101
+//#define CONFIG_ETHADDR 00:0c:29:d8:ab:11
+
+//office
+#define CONFIG_IPADDR		192.168.123.8
+#define CONFIG_SERVERIP		192.168.123.7
+#define CONFIG_ETHADDR 00:0c:29:4f:75:b3
+
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT	"SMDK2440 # "
+#define CONFIG_SYS_CBSIZE	256
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + \
+				sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE
+
+#define CONFIG_DISPLAY_CPUINFO				/* Display cpu info */
+
+#define CONFIG_SYS_MEMTEST_START	0x30000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x33F00000	/* 63 MB in DRAM */
+
+#define CONFIG_SYS_LOAD_ADDR		0x30800000
+
+#define CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* support additional compression methods */
+#define CONFIG_BZIP2
+#define CONFIG_LZO
+#define CONFIG_LZMA
+#define CONFIG_CMD_NAND_YAFFS
+#define CONFIG_BOOTARGS "console=ttySAC0 root=/dev/mtdblock3"
+#define CONFIG_BOOTCOMMAND "nand read 30000000 kernel;bootm 30000000"
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1          /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #0 */
+
+#define CONFIG_SYS_FLASH_BASE	PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_LEGACY
+#define CONFIG_SYS_FLASH_LEGACY_512Kx16
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BANKS_LIST     { CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_MAX_FLASH_SECT	(128)
+#if 0
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x070000)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_SIZE			0x10000
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#endif
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET 0x00040000
+#define CONFIG_ENV_SIZE 0x00020000
+#define CONFIG_ENV_RANGE CONFIG_ENV_SIZE
+
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+#define MTDIDS_DEFAULT "nand0=jz2440-0"
+#define MTDPARTS_DEFAULT "mtdparts=jz2440-0:256k(u-boot)," \
+						 "128k(params)," \
+						 "2m(kernel)," \
+						 "-(rootfs)" \
+
+
+/*
+ * Size of malloc() pool
+ * BZIP2 / LZO / LZMA need a lot of RAM
+ */
+#define CONFIG_SYS_MALLOC_LEN	(4 * 1024 * 1024)
+
+#define CONFIG_SYS_MONITOR_LEN	(448 * 1024)
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
+
+/*
+ * NAND configuration
+ */
+#ifdef CONFIG_CMD_NAND
+#ifdef CONFIG_S3C2410
+#define CONFIG_NAND_S3C2410
+#define CONFIG_SYS_S3C2410_NAND_HWECC
+#else
+#define CONFIG_NAND_S3C2440
+#define CONFIG_SYS_S3C2440_NAND_HWECC
+#endif
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x4E000000
+#endif
+
+/*
+ * File system
+ */
+#if 0
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_UBI
+#define CONFIG_CMD_UBIFS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_YAFFS2 
+#define CONFIG_RBTREE
+#endif
+
+/* additions for new relocation code, must be added to all boards */
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_SDRAM_BASE + 0x1000 - \
+				GENERATED_GBL_DATA_SIZE)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#endif /* __CONFIG_H */
Binary files u-boot-2012.04.01/include/configs/.smdk2440.h.swp and u-boot-2012.04.01_zgm/include/configs/.smdk2440.h.swp differ
